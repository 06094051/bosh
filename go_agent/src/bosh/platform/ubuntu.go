package platform

import (
	bosherr "bosh/errors"
	boshdisk "bosh/platform/disk"
	boshsettings "bosh/settings"
	boshsys "bosh/system"
	"bytes"
	"errors"
	"fmt"
	sigar "github.com/cloudfoundry/gosigar"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"text/template"
	"time"
)

type ubuntu struct {
	fs              boshsys.FileSystem
	cmdRunner       boshsys.CmdRunner
	partitioner     boshdisk.Partitioner
	diskWaitTimeout time.Duration
}

func newUbuntuPlatform(fs boshsys.FileSystem, cmdRunner boshsys.CmdRunner, partitioner boshdisk.Partitioner) (platform ubuntu) {
	platform.fs = fs
	platform.cmdRunner = cmdRunner
	platform.partitioner = partitioner
	platform.diskWaitTimeout = 3 * time.Minute
	return
}

func (p ubuntu) SetupSsh(publicKey, username string) (err error) {
	homeDir, err := p.fs.HomeDir(username)
	if err != nil {
		return bosherr.WrapError(err, "Error finding home dir for user")
	}

	sshPath := filepath.Join(homeDir, ".ssh")
	p.fs.MkdirAll(sshPath, os.FileMode(0700))
	p.fs.Chown(sshPath, username)

	authKeysPath := filepath.Join(sshPath, "authorized_keys")
	_, err = p.fs.WriteToFile(authKeysPath, publicKey)
	if err != nil {
		return bosherr.WrapError(err, "Error creating authorized_keys file")
	}

	p.fs.Chown(authKeysPath, username)
	p.fs.Chmod(authKeysPath, os.FileMode(0600))

	return
}

func (p ubuntu) SetupDhcp(networks boshsettings.Networks) (err error) {
	dnsServers := []string{}
	dnsNetwork, found := networks.DefaultNetworkFor("dns")
	if found {
		for i := len(dnsNetwork.Dns) - 1; i >= 0; i-- {
			dnsServers = append(dnsServers, dnsNetwork.Dns[i])
		}
	}

	type dhcpConfigArg struct {
		DnsServers []string
	}

	buffer := bytes.NewBuffer([]byte{})
	t := template.Must(template.New("dhcp-config").Parse(DHCP_CONFIG_TEMPLATE))

	err = t.Execute(buffer, dhcpConfigArg{dnsServers})
	if err != nil {
		return
	}

	written, err := p.fs.WriteToFile("/etc/dhcp3/dhclient.conf", buffer.String())
	if err != nil {
		return
	}

	if written {
		// Ignore errors here, just run the commands
		p.cmdRunner.RunCommand("pkill", "dhclient3")
		p.cmdRunner.RunCommand("/etc/init.d/networking", "restart")
	}

	return
}

// DHCP Config file - /etc/dhcp3/dhclient.conf
const DHCP_CONFIG_TEMPLATE = `# Generated by bosh-agent

option rfc3442-classless-static-routes code 121 = array of unsigned integer 8;

send host-name "<hostname>";

request subnet-mask, broadcast-address, time-offset, routers,
	domain-name, domain-name-servers, domain-search, host-name,
	netbios-name-servers, netbios-scope, interface-mtu,
	rfc3442-classless-static-routes, ntp-servers;

{{ range .DnsServers }}prepend domain-name-servers {{ . }};
{{ end }}`

func (p ubuntu) SetupEphemeralDiskWithPath(devicePath, mountPoint string) (err error) {
	p.fs.MkdirAll(mountPoint, os.FileMode(0750))

	realPath, err := p.getRealDevicePath(devicePath)
	if err != nil {
		return
	}

	swapSize, linuxSize, err := p.calculateEphemeralDiskPartitionSizes(realPath)
	if err != nil {
		return
	}

	partitions := []boshdisk.Partition{
		{SizeInBlocks: swapSize, Type: boshdisk.PartitionTypeSwap},
		{SizeInBlocks: linuxSize, Type: boshdisk.PartitionTypeLinux},
	}

	p.partitioner.Partition(realPath, partitions)

	swapDevicePath := realPath + "1"
	dataDevicePath := realPath + "2"
	p.cmdRunner.RunCommand("mkswap", swapDevicePath)
	p.cmdRunner.RunCommand("mke2fs", "-t", "ext4", "-j", dataDevicePath)

	p.cmdRunner.RunCommand("swapon", swapDevicePath)
	p.cmdRunner.RunCommand("mount", dataDevicePath, mountPoint)

	p.fs.MkdirAll(filepath.Join(mountPoint, "sys", "log"), os.FileMode(0750))
	p.fs.MkdirAll(filepath.Join(mountPoint, "sys", "run"), os.FileMode(0750))
	return
}

func (p ubuntu) getRealDevicePath(devicePath string) (realPath string, err error) {
	stopAfter := time.Now().Add(p.diskWaitTimeout)

	realPath, found := p.findPossibleDevice(devicePath)
	for !found {
		if time.Now().After(stopAfter) {
			err = errors.New(fmt.Sprintf("Timed out getting real device path for %s", devicePath))
			return
		}
		time.Sleep(100 * time.Millisecond)
		realPath, found = p.findPossibleDevice(devicePath)
	}

	return
}

func (p ubuntu) findPossibleDevice(devicePath string) (realPath string, found bool) {
	pathSuffix := strings.Split(devicePath, "/dev/sd")[1]

	possiblePrefixes := []string{"/dev/xvd", "/dev/vd", "/dev/sd"}
	for _, prefix := range possiblePrefixes {
		path := prefix + pathSuffix
		if p.fs.FileExists(path) {
			realPath = path
			found = true
			return
		}
	}
	return
}

func (p ubuntu) calculateEphemeralDiskPartitionSizes(devicePath string) (swapSize, linuxSize uint64, err error) {
	memStats, err := p.GetMemStats()
	if err != nil {
		return
	}

	blockSizeInBytes := uint64(512)
	totalMemInKb := memStats.Total
	totalMemInBlocks := totalMemInKb * uint64(1024) / blockSizeInBytes

	diskSizeInBlocks, err := p.getBlockDeviceSizeInBlocks(devicePath)
	if err != nil {
		return
	}

	if totalMemInBlocks > diskSizeInBlocks/2 {
		swapSize = diskSizeInBlocks / 2
	} else {
		swapSize = totalMemInBlocks
	}

	linuxSize = diskSizeInBlocks - swapSize
	return
}

func (p ubuntu) getBlockDeviceSizeInBlocks(devicePath string) (size uint64, err error) {
	stdout, _, err := p.cmdRunner.RunCommand("sfdisk", "-s", devicePath)
	if err != nil {
		return
	}

	intSize, err := strconv.Atoi(stdout)
	if err != nil {
		return
	}

	size = uint64(intSize)
	return
}

func (p ubuntu) GetCpuLoad() (load CpuLoad, err error) {
	l := sigar.LoadAverage{}
	err = l.Get()
	if err != nil {
		return
	}

	load.One = l.One
	load.Five = l.Five
	load.Fifteen = l.Fifteen

	return
}

func (p ubuntu) GetCpuStats() (stats CpuStats, err error) {
	cpu := sigar.Cpu{}
	err = cpu.Get()
	if err != nil {
		return
	}

	stats.User = cpu.User
	stats.Sys = cpu.Sys
	stats.Wait = cpu.Wait
	stats.Total = cpu.Total()

	return
}

func (p ubuntu) GetMemStats() (stats MemStats, err error) {
	mem := sigar.Mem{}
	err = mem.Get()
	if err != nil {
		return
	}

	stats.Total = mem.Total
	stats.Used = mem.Used

	return
}

func (p ubuntu) GetSwapStats() (stats MemStats, err error) {
	swap := sigar.Swap{}
	err = swap.Get()
	if err != nil {
		return
	}

	stats.Total = swap.Total
	stats.Used = swap.Used

	return
}

func (p ubuntu) GetDiskStats(mountedPath string) (stats DiskStats, err error) {
	fsUsage := sigar.FileSystemUsage{}
	err = fsUsage.Get(mountedPath)
	if err != nil {
		return
	}

	stats.Total = fsUsage.Total
	stats.Used = fsUsage.Used
	stats.InodeTotal = fsUsage.Files
	stats.InodeUsed = fsUsage.Files - fsUsage.FreeFiles

	return
}
