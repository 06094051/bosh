package platform

import (
	bosherr "bosh/errors"
	boshcmd "bosh/platform/commands"
	boshstats "bosh/platform/stats"
	boshvitals "bosh/platform/vitals"
	boshsettings "bosh/settings"
	boshdir "bosh/settings/directories"
	boshsys "bosh/system"
	"bytes"
	"path/filepath"
	"text/template"
	"time"
)

type ubuntu struct {
	linux           linux
	arpWaitInterval time.Duration
}

func NewUbuntuPlatform(
	linux linux,
	arpWaitInterval time.Duration,
) (platform ubuntu) {
	platform.linux = linux
	platform.arpWaitInterval = arpWaitInterval
	return
}

func (p ubuntu) GetFs() (fs boshsys.FileSystem) {
	return p.linux.GetFs()
}

func (p ubuntu) GetRunner() (runner boshsys.CmdRunner) {
	return p.linux.GetRunner()
}

func (p ubuntu) GetStatsCollector() (statsCollector boshstats.StatsCollector) {
	return p.linux.GetStatsCollector()
}

func (p ubuntu) GetCompressor() (runner boshcmd.Compressor) {
	return p.linux.GetCompressor()
}

func (p ubuntu) GetCopier() (runner boshcmd.Copier) {
	return p.linux.GetCopier()
}

func (p ubuntu) GetDirProvider() (dirProvider boshdir.DirectoriesProvider) {
	return p.linux.GetDirProvider()
}

func (p ubuntu) GetVitalsService() (service boshvitals.Service) {
	return p.linux.GetVitalsService()
}

func (p ubuntu) SetupRuntimeConfiguration() (err error) {
	return p.linux.SetupRuntimeConfiguration()
}

func (p ubuntu) CreateUser(username, password, basePath string) (err error) {
	return p.linux.CreateUser(username, password, basePath)
}

func (p ubuntu) AddUserToGroups(username string, groups []string) (err error) {
	return p.linux.AddUserToGroups(username, groups)
}

func (p ubuntu) DeleteEphemeralUsersMatching(reg string) (err error) {
	return p.linux.DeleteEphemeralUsersMatching(reg)
}

func (p ubuntu) SetupSsh(publicKey, username string) (err error) {
	return p.linux.SetupSsh(publicKey, username)
}

func (p ubuntu) SetUserPassword(user, encryptedPwd string) (err error) {
	return p.linux.SetUserPassword(user, encryptedPwd)
}

func (p ubuntu) SetupHostname(hostname string) (err error) {
	return p.linux.SetupHostname(hostname)
}

func (p ubuntu) SetupLogrotate(groupName, basePath, size string) (err error) {
	return p.linux.SetupLogrotate(groupName, basePath, size)
}

func (p ubuntu) SetTimeWithNtpServers(servers []string) (err error) {
	return p.linux.SetTimeWithNtpServers(servers)
}

func (p ubuntu) SetupEphemeralDiskWithPath(realPath string) (err error) {
	return p.linux.SetupEphemeralDiskWithPath(realPath)
}

func (p ubuntu) SetupTmpDir() (err error) {
	return p.linux.SetupTmpDir()
}

func (p ubuntu) MountPersistentDisk(devicePath, mountPoint string) (err error) {
	return p.linux.MountPersistentDisk(devicePath, mountPoint)
}

func (p ubuntu) UnmountPersistentDisk(devicePath string) (didUnmount bool, err error) {
	return p.linux.UnmountPersistentDisk(devicePath)
}

func (p ubuntu) NormalizeDiskPath(devicePath string) (realPath string, found bool) {
	return p.linux.NormalizeDiskPath(devicePath)
}

func (p ubuntu) GetFileContentsFromCDROM(fileName string) (contents []byte, err error) {
	return p.linux.GetFileContentsFromCDROM(fileName)
}

func (p ubuntu) IsMountPoint(path string) (result bool, err error) {
	return p.linux.IsMountPoint(path)
}

func (p ubuntu) MigratePersistentDisk(fromMountPoint, toMountPoint string) (err error) {
	return p.linux.MigratePersistentDisk(fromMountPoint, toMountPoint)
}

func (p ubuntu) IsDevicePathMounted(path string) (result bool, err error) {
	return p.linux.IsDevicePathMounted(path)
}

func (p ubuntu) StartMonit() (err error) {
	return p.linux.StartMonit()
}

func (p ubuntu) SetupMonitUser() (err error) {
	return p.linux.SetupMonitUser()
}

func (p ubuntu) GetMonitCredentials() (username, password string, err error) {
	return p.linux.GetMonitCredentials()
}

func (p ubuntu) getDnsServers(networks boshsettings.Networks) (dnsServers []string) {
	dnsNetwork, found := networks.DefaultNetworkFor("dns")
	if found {
		for i := len(dnsNetwork.Dns) - 1; i >= 0; i-- {
			dnsServers = append(dnsServers, dnsNetwork.Dns[i])
		}
	}

	return
}

type dnsConfigArg struct {
	DnsServers []string
}

func (p ubuntu) SetupDhcp(networks boshsettings.Networks) (err error) {
	dnsServers := p.getDnsServers(networks)

	buffer := bytes.NewBuffer([]byte{})
	t := template.Must(template.New("dhcp-config").Parse(UBUNTU_DHCP_CONFIG_TEMPLATE))

	err = t.Execute(buffer, dnsConfigArg{dnsServers})
	if err != nil {
		err = bosherr.WrapError(err, "Generating config from template")
		return
	}

	written, err := p.linux.GetFs().WriteToFile("/etc/dhcp3/dhclient.conf", buffer.String())
	if err != nil {
		err = bosherr.WrapError(err, "Writing to /etc/dhcp3/dhclient.conf")
		return
	}

	if written {
		// Ignore errors here, just run the commands
		p.linux.GetRunner().RunCommand("pkill", "dhclient3")
		p.linux.GetRunner().RunCommand("/etc/init.d/networking", "restart")
	}

	return
}

// DHCP Config file - /etc/dhcp3/dhclient.conf
const UBUNTU_DHCP_CONFIG_TEMPLATE = `# Generated by bosh-agent

option rfc3442-classless-static-routes code 121 = array of unsigned integer 8;

send host-name "<hostname>";

request subnet-mask, broadcast-address, time-offset, routers,
	domain-name, domain-name-servers, domain-search, host-name,
	netbios-name-servers, netbios-scope, interface-mtu,
	rfc3442-classless-static-routes, ntp-servers;

{{ range .DnsServers }}prepend domain-name-servers {{ . }};
{{ end }}`

type customNetwork struct {
	boshsettings.Network
	Interface         string
	NetworkIp         string
	Broadcast         string
	HasDefaultGateway bool
}

func (p ubuntu) SetupManualNetworking(networks boshsettings.Networks) (err error) {
	modifiedNetworks, err := p.writeNetworkInterfaces(networks)
	if err != nil {
		err = bosherr.WrapError(err, "Writing network interfaces")
		return
	}

	p.restartNetworkingInterfaces(modifiedNetworks)

	err = p.writeResolvConf(networks)
	if err != nil {
		err = bosherr.WrapError(err, "Writing resolv.conf")
		return
	}

	go p.gratuitiousArp(modifiedNetworks)

	return
}

func (p ubuntu) gratuitiousArp(networks []customNetwork) {
	for i := 0; i < 6; i++ {
		for _, network := range networks {
			for !p.linux.GetFs().FileExists(filepath.Join("/sys/class/net", network.Interface)) {
				time.Sleep(100 * time.Millisecond)
			}

			p.linux.GetRunner().RunCommand("arping", "-c", "1", "-U", "-I", network.Interface, network.Ip)
			time.Sleep(p.arpWaitInterval)
		}
	}
	return
}

func (p ubuntu) writeNetworkInterfaces(networks boshsettings.Networks) (modifiedNetworks []customNetwork, err error) {
	macAddresses, err := p.detectMacAddresses()
	if err != nil {
		err = bosherr.WrapError(err, "Detecting mac addresses")
		return
	}

	for _, aNet := range networks {
		var network, broadcast string
		network, broadcast, err = boshsys.CalculateNetworkAndBroadcast(aNet.Ip, aNet.Netmask)
		if err != nil {
			err = bosherr.WrapError(err, "Calculating network and broadcast")
			return
		}

		newNet := customNetwork{
			aNet,
			macAddresses[aNet.Mac],
			network,
			broadcast,
			true,
		}
		modifiedNetworks = append(modifiedNetworks, newNet)
	}

	buffer := bytes.NewBuffer([]byte{})
	t := template.Must(template.New("network-interfaces").Parse(UBUNTU_NETWORK_INTERFACES_TEMPLATE))

	err = t.Execute(buffer, modifiedNetworks)
	if err != nil {
		err = bosherr.WrapError(err, "Generating config from template")
		return
	}

	_, err = p.linux.GetFs().WriteToFile("/etc/network/interfaces", buffer.String())
	if err != nil {
		err = bosherr.WrapError(err, "Writing to /etc/network/interfaces")
		return
	}

	return
}

const UBUNTU_NETWORK_INTERFACES_TEMPLATE = `auto lo
iface lo inet loopback
{{ range . }}
auto {{ .Interface }}
iface {{ .Interface }} inet static
    address {{ .Ip }}
    network {{ .NetworkIp }}
    netmask {{ .Netmask }}
    broadcast {{ .Broadcast }}
{{ if .HasDefaultGateway }}    gateway {{ .Gateway }}{{ end }}{{ end }}`

func (p ubuntu) writeResolvConf(networks boshsettings.Networks) (err error) {
	buffer := bytes.NewBuffer([]byte{})
	t := template.Must(template.New("resolv-conf").Parse(UBUNTU_RESOLV_CONF_TEMPLATE))

	dnsServers := p.getDnsServers(networks)
	dnsServersArg := dnsConfigArg{dnsServers}
	err = t.Execute(buffer, dnsServersArg)
	if err != nil {
		err = bosherr.WrapError(err, "Generating config from template")
		return
	}

	_, err = p.linux.GetFs().WriteToFile("/etc/resolv.conf", buffer.String())
	if err != nil {
		err = bosherr.WrapError(err, "Writing to /etc/resolv.conf")
		return
	}

	return
}

const UBUNTU_RESOLV_CONF_TEMPLATE = `{{ range .DnsServers }}nameserver {{ . }}
{{ end }}`

func (p ubuntu) detectMacAddresses() (addresses map[string]string, err error) {
	addresses = map[string]string{}

	filePaths, err := p.linux.GetFs().Glob("/sys/class/net/*")
	if err != nil {
		err = bosherr.WrapError(err, "Getting file list from /sys/class/net")
		return
	}

	var macAddress string
	for _, filePath := range filePaths {
		macAddress, err = p.linux.GetFs().ReadFile(filepath.Join(filePath, "address"))
		if err != nil {
			err = bosherr.WrapError(err, "Reading mac address from file")
			return
		}

		interfaceName := filepath.Base(filePath)
		addresses[macAddress] = interfaceName
	}

	return
}

func (p ubuntu) restartNetworkingInterfaces(networks []customNetwork) {
	for _, network := range networks {
		p.linux.GetRunner().RunCommand("service", "network-interface", "stop", "INTERFACE="+network.Interface)
		p.linux.GetRunner().RunCommand("service", "network-interface", "start", "INTERFACE="+network.Interface)
	}
	return
}
